import { Inject, Injectable, Injector, NgModule, OpaqueToken } from '@angular/core';
import { CommonModule } from '@angular/common';
import { BaseRequestOptions, Headers, Http, HttpModule, RequestMethod, RequestOptions, Response, ResponseOptions, XHRBackend } from '@angular/http';
import { InterceptorService } from 'ng2-interceptors/index';
import { JwtHelper } from 'angular2-jwt';
import { MockBackend } from '@angular/http/testing';

var HANDLER_CONFIG = new OpaqueToken('handler.config');

/*
 * Third party
 */
/**
 * Models
 */
var RequestHandlerService = (function () {
    /**
     * @param {?} injector
     * @param {?} handlerConfig
     */
    function RequestHandlerService(injector, handlerConfig) {
        this.injector = injector;
        this.handlerConfig = handlerConfig;
        this.jwtHelper = new JwtHelper();
    }
    Object.defineProperty(RequestHandlerService.prototype, "http", {
        /**
         * Injects http.
         * @return {?}
         */
        get: function () {
            return this.injector.get(Http);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RequestHandlerService.prototype, "config", {
        /**
         * Config helper function for testing purposes.
         * @return {?}
         */
        get: function () {
            return this.handlerConfig;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Run before any http request is made
     *
     * You can return:
     *   - Request: The modified request
     *   - Nothing: For convenience: It's just like returning the request
     *   - <any>(Observable.throw("cancelled")): Cancels the request,
     *     interrupting it from the pipeline, and calling back 'interceptAfter'
     *     in backwards order of those interceptors that got called up to this point.
     * @param {?} request
     * @return {?}
     */
    RequestHandlerService.prototype.interceptBefore = function (request) {
        var _this = this;
        /**
         * Check the request for the presence of a token:
         *  - If no token is present, continue the call as per usual.
         */
        var accessToken = request.options.headers.get(this.config.clientAccessTokenName);
        if (!accessToken || !this.jwtHelper.isTokenExpired(accessToken)) {
            return request;
        }
        var /** @type {?} */ currentCredentials = JSON.parse(localStorage.getItem('auth.headers'));
        /**
         * If there is no access token in local storage,
         * Reassign currentCredentials those in session storage.
         */
        if (!currentCredentials || (currentCredentials && currentCredentials[this.handlerConfig.clientRefreshTokenName] == null)) {
            currentCredentials = JSON.parse(sessionStorage.getItem('auth.headers'));
        }
        /**
         * Set the headers for the request.
         * If the refresh token is not present, throw an error.
         */
        var headers = new Headers();
        if (currentCredentials && currentCredentials[this.handlerConfig.clientRefreshTokenName]) {
            headers.append(this.handlerConfig.serverRefreshTokenName, currentCredentials[this.handlerConfig.clientRefreshTokenName]);
        }
        else {
            throw Error('No Refresh Token available');
        }
        /**
         *  Calls the refresh endpoint
         */
        var obs = this.http.post(this.handlerConfig.refreshUrl, {}, {
            headers: headers,
        }).map(function (res) {
            /**
             *  Handles the response from the endpoint
             *  Returns the original request, which follows the refresh pipeline
             */
            var localItem = JSON.parse(localStorage.getItem('auth.headers'));
            var persist = localItem !== null && localItem[_this.handlerConfig.clientAccessTokenName] !== null;
            // Populate the Auth Headers Object
            var authHeaders = {};
            authHeaders[_this.handlerConfig.clientAccessTokenName] = res.headers.get(_this.handlerConfig.serverAccessTokenName);
            authHeaders[_this.handlerConfig.clientRefreshTokenName] = res.headers.get(_this.handlerConfig.serverRefreshTokenName);
            /**
             * Save to persisiten storage if the current auth items are stored there.
             */
            if (persist) {
                localStorage.setItem('auth.headers', JSON.stringify(authHeaders));
                sessionStorage.removeItem('auth.headers');
            }
            else {
                sessionStorage.setItem('auth.headers', JSON.stringify(authHeaders));
                localStorage.removeItem('auth.headers');
            }
            request.options.headers.set(_this.handlerConfig.serverAccessTokenName, authHeaders[_this.handlerConfig.clientAccessTokenName]);
            return request;
        });
        return obs;
    };
    /**
     * @param {?} response
     * @return {?}
     */
    RequestHandlerService.prototype.interceptAfter = function (response) {
        return response;
    };
    return RequestHandlerService;
}());
RequestHandlerService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
RequestHandlerService.ctorParameters = function () { return [
    { type: Injector, },
    { type: undefined, decorators: [{ type: Inject, args: [HANDLER_CONFIG,] },] },
]; };

var validToken = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJPbmxpbmUgSldUIEJ1aWxkZXIiLCJpYXQiOjE1MDc3Mjc3NTcsImV4cCI6MTUwNzczMjUyMywiYXVkIjoid3d3LmV4YW1wbGUuY29tIiwic3ViIjoianJvY2tldEBleGFtcGxlLmNvbSIsIkdpdmVuTmFtZSI6IkpvaG5ueSIsIlN1cm5hbWUiOiJSb2NrZXQiLCJFbWFpbCI6Impyb2NrZXRAZXhhbXBsZS5jb20iLCJSb2xlIjpbIk1hbmFnZXIiLCJQcm9qZWN0IEFkbWluaXN0cmF0b3IiXX0.XSlAo8SL-pLBK4eLCPLAGZ4Mz732x2yGAM4WW_PwmYg';

/**
 * @param {?} backend
 * @param {?} options
 * @param {?} realBackend
 * @return {?}
 */
function fakeBackendFactory(backend, options, realBackend) {
    backend.connections.subscribe(function (connection) {
        /**
         * Simulate response time
         */
        if (connection.request.url.substring(0, 7) === 'test://' && connection.request.method === RequestMethod.Post) {
            var /** @type {?} */ headers = new Headers({
                'X-Access-Token': validToken,
            });
            connection.mockRespond(new Response(new ResponseOptions({
                status: 200,
                headers: headers,
            })));
        }
        else {
            var /** @type {?} */ realHttp = new Http(realBackend, options);
            var /** @type {?} */ requestOptions = new RequestOptions({
                method: connection.request.method,
                headers: connection.request.headers,
                body: connection.request.getBody(),
                url: connection.request.url,
                withCredentials: connection.request.withCredentials,
                responseType: connection.request.responseType
            });
            realHttp.request(connection.request.url, requestOptions)
                .subscribe(function (response) {
                connection.mockRespond(response);
            }, function (error) {
                connection.mockError(error);
            });
        }
        
        return;
    });
    return new Http(backend, options);
}

var fakeBackendProvider = {
    // use fake backend in place of Http service for backend-less development
    provide: Http,
    useFactory: fakeBackendFactory,
    deps: [MockBackend, BaseRequestOptions, XHRBackend]
};

/**
 * @param {?} xhrBackend
 * @param {?} requestOptions
 * @param {?} requestHandlerService
 * @return {?}
 */
function InterceptorFactory(xhrBackend, requestOptions, requestHandlerService) {
    var /** @type {?} */ service = new InterceptorService(xhrBackend, requestOptions);
    service.addInterceptor(requestHandlerService);
    return service;
}
var RequestHandlerModule = (function () {
    function RequestHandlerModule() {
    }
    /**
     * @param {?} handlerConfig
     * @return {?}
     */
    RequestHandlerModule.forRoot = function (handlerConfig) {
        return {
            ngModule: RequestHandlerModule,
            providers: [
                {
                    provide: HANDLER_CONFIG,
                    useValue: handlerConfig
                },
                RequestHandlerService,
                {
                    provide: Http,
                    useFactory: InterceptorFactory,
                    deps: [
                        XHRBackend,
                        RequestOptions,
                        RequestHandlerService,
                    ],
                },
            ]
        };
    };
    /**
     * @param {?} handlerConfig
     * @return {?}
     */
    RequestHandlerModule.forTesting = function (handlerConfig) {
        return {
            ngModule: RequestHandlerModule,
            providers: [
                {
                    provide: HANDLER_CONFIG,
                    useValue: handlerConfig
                },
                RequestHandlerService,
                {
                    provide: Http,
                    useFactory: InterceptorFactory,
                    deps: [
                        XHRBackend,
                        RequestOptions,
                        RequestHandlerService,
                    ],
                },
                fakeBackendProvider,
                MockBackend,
                BaseRequestOptions
            ]
        };
    };
    return RequestHandlerModule;
}());
RequestHandlerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    HttpModule
                ],
                declarations: [],
                exports: []
            },] },
];
/**
 * @nocollapse
 */
RequestHandlerModule.ctorParameters = function () { return []; };

export { InterceptorFactory, RequestHandlerModule, RequestHandlerService };
